var moment=require("../../moment");exports.format={"format YY":function(e){e.expect(1);var a=moment(new Date(2009,1,14,15,25,50,125));e.equal(a.format("YY"),"09","YY ---> 09"),e.done()},"format escape brackets":function(e){e.expect(9),moment.lang("en");var a=moment(new Date(2009,1,14,15,25,50,125));e.equal(a.format("[day]"),"day","Single bracket"),e.equal(a.format("[day] YY [YY]"),"day 09 YY","Double bracket"),e.equal(a.format("[YY"),"[09","Un-ended bracket"),e.equal(a.format("[[YY]]"),"[YY]","Double nested brackets"),e.equal(a.format("[[]"),"[","Escape open bracket"),e.equal(a.format("[Last]"),"Last","localized tokens"),e.equal(a.format("[L] L"),"L 02/14/2009","localized tokens with escaped localized tokens"),e.equal(a.format("[L LL LLL LLLL aLa]"),"L LL LLL LLLL aLa","localized tokens with escaped localized tokens"),e.equal(a.format("[LLL] LLL"),"LLL February 14 2009 3:25 PM","localized tokens with escaped localized tokens (recursion)"),e.done()},"format milliseconds":function(e){e.expect(6);var a=moment(new Date(2009,1,14,15,25,50,123));e.equal(a.format("S"),"1","Deciseconds"),e.equal(a.format("SS"),"12","Centiseconds"),e.equal(a.format("SSS"),"123","Milliseconds"),a.milliseconds(789),e.equal(a.format("S"),"7","Deciseconds"),e.equal(a.format("SS"),"78","Centiseconds"),e.equal(a.format("SSS"),"789","Milliseconds"),e.done()},"format timezone":function(e){e.expect(2);var a=moment(new Date(2010,1,14,15,25,50,125)),o='moment().format("z") = '+a.format("z")+' It should be something like "PST"';-60===moment().zone()&&(o+="For UTC+1 this is a known issue, see https://github.com/timrwood/moment/issues/162"),e.ok(a.format("Z").match(/^[\+\-]\d\d:\d\d$/),a.format("Z")+' should be something like "+07:30"'),e.ok(a.format("ZZ").match(/^[\+\-]\d{4}$/),a.format("ZZ")+' should be something like "+0700"'),e.done()},"format multiple with zone":function(e){e.expect(1);var a=moment("2012-10-08 -1200",["YYYY ZZ","YYYY-MM-DD ZZ"]);e.equals(a.format("YYYY-MM"),"2012-10","Parsing multiple formats should not crash with different sized formats"),e.done()},isDST:function(e){e.expect(2);var a=new Date(2011,0,1).getTimezoneOffset(),o=new Date(2011,6,1).getTimezoneOffset(),n=o>a,t=a>o,m=moment([2011]),d=moment([2011,6]);n&&t?(e.ok(0,"January and July cannot both be in DST"),e.ok(0,"January and July cannot both be in DST")):n?(e.ok(m.isDST(),"January 1 is DST"),e.ok(!d.isDST(),"July 1 is not DST")):t?(e.ok(!m.isDST(),"January 1 is not DST"),e.ok(d.isDST(),"July 1 is DST")):(e.ok(!m.isDST(),"January 1 is not DST"),e.ok(!d.isDST(),"July 1 is not DST")),e.done()},"unix timestamp":function(e){e.expect(4);var a=moment("1234567890.123","X");e.equals(a.format("X"),"1234567890","unix timestamp without milliseconds"),e.equals(a.format("X.S"),"1234567890.1","unix timestamp with deciseconds"),e.equals(a.format("X.SS"),"1234567890.12","unix timestamp with centiseconds"),e.equals(a.format("X.SSS"),"1234567890.123","unix timestamp with milliseconds"),e.done()},zone:function(e){e.expect(3),moment().zone()>0&&e.ok(moment().format("ZZ").indexOf("-")>-1,"When the zone() offset is greater than 0, the ISO offset should be less than zero"),0>moment().zone()&&e.ok(moment().format("ZZ").indexOf("+")>-1,"When the zone() offset is less than 0, the ISO offset should be greater than zero"),0==moment().zone()&&e.ok(moment().format("ZZ").indexOf("+")>-1,"When the zone() offset is equal to 0, the ISO offset should be positive zero"),0===moment().zone()?e.equal(moment().zone(),0,"moment.fn.zone should be a multiple of 15 (was "+moment().zone()+")"):e.equal(moment().zone()%15,0,"moment.fn.zone should be a multiple of 15 (was "+moment().zone()+")"),e.equal(moment().zone(),(new Date).getTimezoneOffset(),"zone should equal getTimezoneOffset"),e.done()},"default format":function(e){e.expect(1);var a=/\d{4}.\d\d.\d\dT\d\d.\d\d.\d\d[\+\-]\d\d:\d\d/;e.ok(a.exec(moment().format()),"default format ("+moment().format()+") should match ISO"),e.done()},"escaping quotes":function(e){e.expect(4),moment.lang("en");var a=moment([2012,0]);e.equal(a.format("MMM 'YY"),"Jan '12","Should be able to format with single parenthesis"),e.equal(a.format('MMM "YY'),'Jan "12',"Should be able to format with double parenthesis"),e.equal(a.format("MMM 'YY"),"Jan '12","Should be able to format with single parenthesis"),e.equal(a.format('MMM "YY'),'Jan "12',"Should be able to format with double parenthesis"),e.done()},toJSON:function(e){var a="undefined"!=typeof JSON&&JSON.stringify&&JSON.stringify.call,o=moment.utc("2012-10-09T20:30:40.678");e.expect(a?2:1),e.equal(o.toJSON(),"2012-10-09T20:30:40.678Z","should output ISO8601 on moment.fn.toJSON"),e.equal(JSON.stringify({date:o}),'{"date":"2012-10-09T20:30:40.678Z"}',"should output ISO8601 on JSON.stringify"),e.done()},"weeks format":function(e){var a={"2005-01-02":"2004-53","2005-12-31":"2005-52","2007-01-01":"2007-01","2007-12-30":"2007-52","2007-12-31":"2008-01","2008-01-01":"2008-01","2008-12-28":"2008-52","2008-12-29":"2009-01","2008-12-30":"2009-01","2008-12-31":"2009-01","2009-01-01":"2009-01","2009-12-31":"2009-53","2010-01-01":"2009-53","2010-01-02":"2009-53","2010-01-03":"2009-53"};for(var o in a){var n=a[o].split("-").pop(),t=moment(o).format("WW");e.equal(n,t,o+": should be "+n+", but "+t)}e.done()},"toString is just human readable format":function(e){e.expect(1);var a=moment(new Date(2009,1,5,15,25,50,125));e.equal(""+a,a.format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")),e.done()}};